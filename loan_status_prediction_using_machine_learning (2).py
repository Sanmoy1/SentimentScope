# -*- coding: utf-8 -*-
"""Loan Status Prediction Using Machine Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-60gqMeL8jSA571AEZvgxSE27ZpvuNgs
"""

import pandas as pd

data = pd.read_csv('loan_prediction.csv')

data.head()

data.tail()

data.shape

print("Number of Rows",data.shape[0])
print("Number of Columns",data.shape[1])

data.info()

data.isnull().sum()

data.isnull().sum()*100 / len(data)

data = data.drop('Loan_ID',axis=1)

data.head(1)

columns = ['Gender','Dependents','LoanAmount','Loan_Amount_Term']

data = data.dropna(subset=columns)

data.isnull().sum()*100 / len(data)

data['Self_Employed'].mode()[0]

data['Self_Employed'] =data['Self_Employed'].fillna(data['Self_Employed'].mode()[0])

data.isnull().sum()*100 / len(data)

data['Gender'].unique()

data['Self_Employed'].unique()

data['Credit_History'].mode()[0]

data['Credit_History'] =data['Credit_History'].fillna(data['Credit_History'].mode()[0])

data.isnull().sum()*100 / len(data)

data.sample(5)

data['Dependents'] =data['Dependents'].replace(to_replace="3+",value='4')

data['Dependents'].unique()

data['Loan_Status'].unique()

data['Gender'] = data['Gender'].map({'Male':1,'Female':0}).astype('int')
data['Married'] = data['Married'].map({'Yes':1,'No':0}).astype('int')
data['Education'] = data['Education'].map({'Graduate':1,'Not Graduate':0}).astype('int')
data['Self_Employed'] = data['Self_Employed'].map({'Yes':1,'No':0}).astype('int')
data['Property_Area'] = data['Property_Area'].map({'Rural':0,'Semiurban':2,'Urban':1}).astype('int')
data['Loan_Status'] = data['Loan_Status'].map({'Y':1,'N':0}).astype('int')

data.head()

X = data.drop('Loan_Status',axis=1)

y = data['Loan_Status']

y

data.head()

cols = ['ApplicantIncome','CoapplicantIncome','LoanAmount','Loan_Amount_Term']

from sklearn.preprocessing import StandardScaler
st = StandardScaler()
X[cols]=st.fit_transform(X[cols])

X

from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.metrics import accuracy_score
import numpy as np

model_df={}
def model_val(model,X,y):
    X_train,X_test,y_train,y_test=train_test_split(X,y,
                                                   test_size=0.20,
                                                   random_state=42)
    model.fit(X_train,y_train)
    y_pred=model.predict(X_test)
    print(f"{model} accuracy is {accuracy_score(y_test,y_pred)}")

    score = cross_val_score(model,X,y,cv=5)
    print(f"{model} Avg cross val score is {np.mean(score)}")
    model_df[model]=round(np.mean(score)*100,2)

model_df

from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
model_val(model,X,y)

from sklearn import svm
model = svm.SVC()
model_val(model,X,y)

from sklearn.tree import DecisionTreeClassifier
model = DecisionTreeClassifier()
model_val(model,X,y)

from sklearn.ensemble import RandomForestClassifier
model =RandomForestClassifier()
model_val(model,X,y)

from sklearn.ensemble import GradientBoostingClassifier
model =GradientBoostingClassifier()
model_val(model,X,y)



from sklearn.model_selection import RandomizedSearchCV

log_reg_grid={"C":np.logspace(-4,4,20),
             "solver":['liblinear']}

rs_log_reg=RandomizedSearchCV(LogisticRegression(),
                   param_distributions=log_reg_grid,
                  n_iter=20,cv=5,verbose=True)

rs_log_reg.fit(X,y)

rs_log_reg.best_score_

rs_log_reg.best_params_

svc_grid = {'C':[0.25,0.50,0.75,1],"kernel":["linear"]}

rs_svc=RandomizedSearchCV(svm.SVC(),
                  param_distributions=svc_grid,
                   cv=5,
                   n_iter=20,
                  verbose=True)

rs_svc.fit(X,y)

rs_svc.best_score_

rs_svc.best_params_

RandomForestClassifier()

rf_grid={'n_estimators':np.arange(10,1000,10),
  'max_features':['auto','sqrt'],
 'max_depth':[None,3,5,10,20,30],
 'min_samples_split':[2,5,20,50,100],
 'min_samples_leaf':[1,2,5,10]
 }

rs_rf=RandomizedSearchCV(RandomForestClassifier(),
                  param_distributions=rf_grid,
                   cv=5,
                   n_iter=20,
                  verbose=True)

rs_rf.fit(X,y)

rs_rf.best_score_

rs_rf.best_params_

"""### Save The Model"""

X = data.drop('Loan_Status',axis=1)
y = data['Loan_Status']

rf = RandomForestClassifier(n_estimators=270,
 min_samples_split=5,
 min_samples_leaf=5,
 max_features='sqrt',
 max_depth=5)

rf.fit(X,y)

import joblib

joblib.dump(rf,'loan_status_predict')

model = joblib.load('loan_status_predict')

import pandas as pd
df = pd.DataFrame({
    'Gender':1,
    'Married':1,
    'Dependents':2,
    'Education':0,
    'Self_Employed':0,
    'ApplicantIncome':2889,
    'CoapplicantIncome':0.0,
    'LoanAmount':45,
    'Loan_Amount_Term':180,
    'Credit_History':0,
    'Property_Area':1
},index=[0])

df

result = model.predict(df)

if result==1:
    print("Loan Approved")
else:
    print("Loan Not Approved")

import pandas as pd
from sklearn.ensemble import RandomForestClassifier
import joblib
import numpy as np
import tensorflow as tf

# ... (Previous code for data preprocessing)

# Train the RandomForestClassifier model
X = data.drop('Loan_Status', axis=1)
y = data['Loan_Status']

rf = RandomForestClassifier(n_estimators=270,
                            min_samples_split=5,
                            min_samples_leaf=5,
                            max_features='sqrt',
                            max_depth=5)
rf.fit(X, y)

# Save the trained model using joblib
joblib.dump(rf, 'loan_status_predict.pkl')

# Load the trained model
model = joblib.load('loan_status_predict.pkl')

# Function to take user input and make predictions
def predict_loan_approval():
    gender = int(input("Enter Gender (Male: 1, Female: 0): "))
    married = int(input("Married? (Yes: 1, No: 0): "))
    dependents = int(input("Number of Dependents: "))
    education = int(input("Education (Graduate: 1, Not Graduate: 0): "))
    self_employed = int(input("Self Employed? (Yes: 1, No: 0): "))
    applicant_income = float(input("Applicant's Income: "))
    coapplicant_income = float(input("Coapplicant's Income: "))
    loan_amount = float(input("Loan Amount (in thousands): "))
    loan_amount_term = float(input("Loan Amount Term (in months): "))
    credit_history = int(input("Credit History meets guidelines? (Yes: 1, No: 0): "))
    property_area = int(input("Property Area (Rural: 0, Semi Urban: 2, Urban: 1): "))

    # Create a DataFrame with the user input
    user_data = pd.DataFrame({
        'Gender': [gender],
        'Married': [married],
        'Dependents': [dependents],
        'Education': [education],
        'Self_Employed': [self_employed],
        'ApplicantIncome': [applicant_income],
        'CoapplicantIncome': [coapplicant_income],
        'LoanAmount': [loan_amount],
        'Loan_Amount_Term': [loan_amount_term],
        'Credit_History': [credit_history],
        'Property_Area': [property_area]
    })

    # Make prediction using the model
    result = model.predict(user_data)

    if result == 1:
        print("Loan Approved")
    else:
        print("Loan Not Approved")

# Call the function to make predictions based on user input
predict_loan_approval()

